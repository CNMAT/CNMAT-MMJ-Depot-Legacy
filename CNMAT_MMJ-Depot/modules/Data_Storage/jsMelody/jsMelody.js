/*jsMelody.js by Michael Zbyszynski, 080326Written by Michael Zbyszynski, The Center for New Music and Audio Technologies,University of California, Berkeley.  Copyright (c) 2007, The Regents of the University of California (Regents).  Permission to use, copy, modify, distribute, and distribute modified versionsof this software and its documentation without fee and without a signedlicensing agreement, is hereby granted, provided that the above copyrightnotice, this paragraph and the following two paragraphs appear in all copies,modifications, and distributions.IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISINGOUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HASBEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDEDHEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDEMAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NAME: jsChordDESCRIPTION: visual feedback for rhythms and melodies (javascript UI)AUTHORS: Michael ZbyszynskiCOPYRIGHT_YEARS: 2008SVN_REVISION: $LastChangedRevision: ??? $VERSION 0.1: First release@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/outlets = 2;sketch.default2d();var mybrgb = [1,1,1];var myfrgb = [0,0,0];var myrgb2 = [1,1,1];var myfont = "Sonora";var notes = new Array();var noteSpace = 0.25;var microTone = 1;var accidents = 0;draw();function draw(){	var str,width,height,aspect;	height = box.rect[3] - box.rect[1]; 	width = box.rect[2] - box.rect[0]; 	aspect = width/height;			with (sketch) {		//erase background		glclearcolor(1,1,1);		glclear();			drawstaff(0, "&");		drawstaff(-.29, "?");		drawstaff(-.625, "t");		drawstaff(.34, "&");		xpos = -.7		drawnotes();	}}function list(){	notes.length = 0;	for ( i=0 ; i < arguments.length ; i++)	{		notes[i] = arguments [i];	}	bang();}function drawstaff(xpos, clef){	var str,width,height,aspect;	height = box.rect[3] - box.rect[1]; 	width = box.rect[2] - box.rect[0]; 	aspect = width/height;			with (sketch) {				glcolor(0,0,0);		newX = 1. * aspect		moveto(0,0);		for(i=0;i<5;i++)		{			newY = (i * 0.05) + xpos;			linesegment(-newX, newY, 0.,  newX, newY, 0.);		}		glcolor(0.,0.,0.);		switch(clef){			case "&":			xpos = xpos+.06;			break;			case "?":			xpos = xpos+.165;			break;			case "t":			xpos = xpos+.165;			break;		}		moveto((-newX+.1), xpos);		font(myfont);				fontsize(.145*height);		textalign("center","center");			text(clef);	}}function drawnotes() {	var str,width,height,aspect;	height = box.rect[3] - box.rect[1]; 	width = box.rect[2] - box.rect[0]; 	aspect = width/height;	newX = 1. * aspect;	if (notes.length > 0)	{	 	for (i=0 ; i < notes.length ; i=i+2)		{			currentNote = notes[i];			currentDur = notes[i+1];			currentNote = parseInt(currentNote);			pitchClass = currentNote%12;			sharp = 0;			ledger = 0;			switch(pitchClass)			{				case 1:				currentNote = currentNote-1;				sharp = 1;				break;				case 3:				currentNote = currentNote-1;				sharp = 1;				break;				case 4:				currentNote = currentNote-0.5;				break;				case 6:				currentNote = currentNote-1;				sharp = 1;				break;				case 8:				currentNote = currentNote-1;				sharp = 1;				break;				case 10:				currentNote = currentNote-1;				sharp = 1;				break;				case 11:				currentNote = currentNote-0.5;				break;			}			//for microtones			fracTone = notes[i]%1;			switch (microTone)			{				case 1:				if (fracTone < .75 && fracTone > .25)				{					sharp = sharp+0.5;				}				else if (fracTone >= .75)				{					//currentNote = currentNote+2.;					sharp = sharp+1.;				}				break;				case 3:				if (fracTone > .125 && fracTone < .375)				{					sharp = sharp+0.25;				}				else if (fracTone > .375 && fracTone < .625)				{					sharp = sharp+0.5;				}				else if (fracTone > .625 && fracTone <.875)				{					sharp = sharp+0.75				}				else if (fracTone >.875)				{					sharp = sharp+1.;				}				break;			}			if (sharp == 2.)			{				currentNote = currentNote+2.;				sharp = 0.;			}			switch(currentNote)			{				case 60:				ledger = 1;				break;				case 36:				ledger = -1;				break;				case 38:				ledger = -1;				break;				case 39.5:				ledger = -2;				break;				case 81:				ledger = 2;				break;				case 83:				ledger = 2;				break;				case 84:				ledger = 3				break;				case 86:				ledger = 3;				break;			}			ypos = ((currentNote-60)*.014)-.05;			xpos = -newX+0.3;			with (sketch) 			{				moveto(xpos, ypos);				font(myfont);				fontsize(.15*height);				textalign("center","center");				if (currentNote==0)				{					text(" ");				}				else				{						text("q");				}				//duration line				durX = xpos+.01;				quad(durX,ypos+.17,0.,durX,ypos+.19,0., durX+currentDur,ypos+.19,0., durX+currentDur,ypos+.17,0.);				font("Tempera");				fontsize(.09*height);				switch(sharp)				{						case .25:					moveto (xpos-.09, ypos)					text("V");					break;						case .5:					moveto (xpos-.09, ypos)					text("]");					break;						case .75:					moveto (xpos-.09, ypos)					text("`");					break;						case 1:					moveto (xpos-.09, ypos)					text("g");					break;						case 1.25:					moveto (xpos-.09, ypos)					text("h");					break;						case 1.5:					moveto (xpos-.09, ypos)					text("q");					break;						case 1.75:					moveto (xpos-.09, ypos)					text("s");					break;					}							switch(ledger)				{					case 1:					linesegment(xpos+.03, -.05, 0., xpos-.05, -.05, 0.);					break;						case -1:					linesegment(xpos+.03, -.385, 0., xpos-.05, -.385, 0.);					break;						case -2:					linesegment(xpos+.03, -.335, 0., xpos-.05, -.335, 0.);					linesegment(xpos+.03, -.385, 0., xpos-.05, -.385, 0.);					break;						case 2:					linesegment(xpos+.03, .25, 0., xpos-.05, .25, 0.);					break;						case 3:					linesegment(xpos+.03, .25, 0., xpos-.05, .25, 0.);					linesegment(xpos+.03, .29, 0., xpos-.05, .29, 0.);					break;					}				newX = newX-currentDur;			}		}		}	}function accidentals(a){	accidents = a;	bang();}function micromode(m){	microTone = m;	bang();}function bang(){	draw();	refresh();	outlet(1,notes[0]);	tsk = new Task(rhythmic_output); 	outRate = 1000*noteSpace;	tsk.interval = outRate;	tsk.repeat(notes.length, outRate); 		outlet(0,notes);	}function rhythmic_output() { outlet(1,notes[arguments.callee.task.iterations]); } function onresize(w,h){	draw();	refresh();}onresize.local = 1; //privatefunction onclick(x,y,but,cmd,shift,capslock,option,ctrl){	 ondrag(x,y,but,cmd,shift,capslock,option,ctrl);	if (drag[1]>-0.8){	 	bang();		}}onclick.local = 1; //privatefunction ondrag(x,y,but,cmd,shift,capslock,option,ctrl){	var dragX;	drag = sketch.screentoworld(x,y);	if (drag[1]<-0.8){	 	noteSpace = (drag[0]+1.)/2.		}	if (noteSpace < 0.){		noteSpace = 0.;		}	if (noteSpace > .8){		noteSpace = .8;		}	draw();	refresh();}ondrag.local = 1;